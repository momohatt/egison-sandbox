(load-file "example.egi")

(define $symbol something)

(define $monomial
  (matcher
    {[<degree $> [integer]
      {[$tgt {(length tgt)}]}]
     [<power ,$x $> [integer]
      {[$tgt (match tgt (multiset symbol)
               {[(loop $i [1 $n]
                       <cons ,x ...>
                       !<cons ,x _>) {n}]})]}]
     [<power $ $> [symbol integer]
      {[$tgt (match-all [(unique tgt) tgt] [(multiset symbol) monomial]
               {[[<cons $x _> <power ,x $n>] [x n]]})]}]
     [<mult ,$val $> [monomial]
      {[$tgt (match-all tgt (multiset symbol)
               [<join ,val $rest> rest])]}]
     [$ (multiset symbol)
      {[$tgt {tgt}]}]
     }))

(assert-equal "degree"
  (match {} monomial {[<degree $n> n]})
  0)
(assert-equal "degree"
  (match {x x y} monomial {[<degree $n> n]})
  3)
(assert-equal "power"
  (match-all {x x y} monomial {[<power $x $n> [x n]]})
  {[x 2] [y 1]})
(assert-equal "power"
  (match {x x y} monomial {[<power ,z $n> n]})
  0)

(define $polynomial
  (matcher
    {[<head ,$ord $ $> [integer monomial]
      {[$tgt {(max/fn (lambda [$m1 $m2] (ord-mono-lex ord (snd m1) (snd m2)))
                      tgt)}]}]
     [$ (multiset [integer monomial])
      {[$tgt {tgt}]}]
     }))

(assert-equal "head"
  (match {[1 {x}] [1 {x x}]} polynomial {[<head ,{x} $n $x> [n x]]})
  [1 {x x}])

; Lexicographic Ordering
(define $ord-mono-lex
  (lambda [$l $m1 $m2]
    (match [l m1 m2] [(list symbol) monomial monomial]
      {[[<nil> _ _] <Equal>]
       [[<cons $x $xs> <power ,x $n1> <power ,x $n2>]
        (match (compare n1 n2) ordering
          {[<equal> (ord-mono-lex xs m1 m2)]
           [$cmp    cmp]})]})))

; Graded Lexicographic Ordering
(define $ord-mono-grlex
  (match-lambda [(list symbol) monomial monomial]
    {[[_ <degree $n1> <degree (& !,n1 $n2)>]
      (compare n1 n2)]
     [[$sym-list $m1 $m2]
      (ord-mono-lex sym-list m1 m2)]}))

(assert-equal "ord-mono-lex"
  (ord-mono-lex {x y z} {x y y} {y y y z z})
  <Greater>)
(assert-equal "ord-mono-lex"
  (ord-mono-lex {x y z} {x x y y y z z z} {x x y z z z z z})
  <Greater>)
(assert-equal "ord-mono-grlex"
  (ord-mono-grlex {x y z} {x y y y z z} {x x x x y})
  <Greater>)
(assert-equal "ord-mono-grlex"
  (ord-mono-grlex {x y z} {x y y y z z} {x y z z z z})
  <Greater>)

(define $non-heads
  (lambda [$poly $ord]
    (match poly polynomial
      {[<head ,ord $c $mono> (delete-first [c mono] poly)]})))

(assert-equal "non-heads"
  (non-heads {[1 {x x}] [1 {y}] [1 {}]}{x y})
  {[1 {y}] [1 {}]})

(define $negate
  (match-all-lambda polynomial
    {[<cons [$c $mono] _> [(neg c) mono]]}))

(define $mult
  (match-all-lambda [[integer monomial] polynomial]
    {[[[$c1 $m1] <cons [$c2 $m2] _>]
      [(* c1 c2) {@m1 @m2}]]
     }))

(define $plus
  (match-all-lambda [polynomial polynomial]
    {[[<cons [$c1 $m1] _> !<cons [_ ,m1] _>] [c1 m1]]
     [[<cons [$c1 $m1] _> <cons [(& !,(neg c1) $c2) ,m1] _>] [(+ c1 c2) m1]]
     [[(later !<cons [_ ,m2] _>) <cons [$c2 $m2] _>] [c2 m2]]
     }))

(assert "plus"
  (match (plus {[2 {x y}] [-1 {x}]} {[1 {x y}] [-1 {y}]}) (multiset something)
    {[,{[3 {x y}] [-1 {x}] [-1 {y}]} #t]}))

(define $rewrite
  (lambda [$eqs $poly $ord]
    (match [eqs (debug/fn show-poly poly)] [(multiset polynomial) polynomial]
      {[[<cons (& $rule <head ,ord ,1 $hf>) _> <cons [$a <mult ,hf $m'>] $rs>]
        (plus rs (mult [a m'] (negate (non-heads rule ord))))]
       [_ poly]})))

(define $normalize
  (lambda [$eqs $poly $ord]
    (let {[$poly' (rewrite eqs poly ord)]}
      (if (eq?/m polynomial poly poly') poly (normalize eqs poly' ord)))))

(define $joinable?
  (lambda [$eqs $poly $ord]
    (eq? (normalize eqs poly ord) {})))

(assert-equal "normalize"
  (normalize {f1 f2} {[-1 {y x x}] [1 {x y y}]} {x y})
  {[-1 {x x}] [1 {y y}]})
(assert-equal "rewrite"
  (rewrite {f1 f2} {[1 {x x y y}]} {x y})
  {[1 {y x x}]})

; ========================== Buchberger's algorithm ============================

(define $lcm
  (lambda [$m1 $m2]
    (concat
      (match-all [m1 m2] [monomial monomial]
        {[[<power $x $n1> <power ,x $n2>] (replicate (max {n1 n2}) x)]
         [[(later <power ,x ,0>) <power $x $n>] (replicate n x)]}))))

(define $s-polynomial
  (lambda [$f1 $f2 $ord]
    (match [f1 f2] [polynomial polynomial]
      {[[<head ,ord ,1 $h1> <head ,ord ,1 $h2>]
        (match (lcm h1 h2) monomial
          {[(& <mult ,h1 $m1> <mult ,h2 $m2>)
            (plus (mult [1 m1] f1) (mult [-1 m2] f2))]})]
       [[<head ,ord $c1 $h1> <head ,ord $c2 $h2>]
        (s-polynomial (mult [(/ 1 c1) {}] f1) (mult [(/ 1 c2) {}] f2) ord)]
        })))

(assert-equal "s-polynomial"
  (s-polynomial f1 f2 {x y})
  {[-1 {y x x}] [1 {x y y}]})
(assert-equal "s-polynomial"
  (s-polynomial {[3 {x x x y}] [2 {x y}] [-1 {y y}]}
                {[2 {x y y}] [-5 {y y y}]}
                {x y})
  {[(/ 2 3) {y x y}] [(/ -1 3) {y y y}] [(/ 5 2) {x x y y y}]})

(define $report
  (lambda [$fs $pairs]
    (print
      (S.concat {(show (length fs)) " equations, "
                 (show (length pairs)) " pending pairs"}))))

(define $buchberger-loop
  (lambda [$pairs $fs $ord]
    (io
      (do {(report fs pairs)}
        (return
          (match pairs (list [polynomial polynomial])
            {[<nil> fs]
             [<cons [$p1 $p2] $pairs'>
              (let {[$h (normalize fs (s-polynomial p1 p2 ord) ord)]}
                (match h polynomial
                  {[<nil> (buchberger-loop pairs' fs ord)]
                   [<head ,ord $c _>
                    (let* {[$h' (mult [(/ 1 c) {}] h)]
                           [$new-pairs (map (lambda $x [x h']) (interreduce fs ord))]}
                      (buchberger-loop {@pairs' @new-pairs}
                                       (cons (debug/fn show-poly h') fs)
                                       ord))]
                   }))]
             }))))))

(define $all-pairs
  (lambda [$fs]
    (match-all fs (list something)
      {[<join _ <cons $f1 <join _ <cons $f2 _>>>> [f1 f2]]})))

(define $interreduce
  (lambda [$fs $ord]
    (match fs (multiset polynomial)
      {[<cons $f (& ?(joinable? $ f ord) $other)>
        (interreduce other ord)]
       [_ fs]})))

(define $buchberger
  (lambda [$fs $ord]
    (buchberger-loop (all-pairs fs) fs ord)))

(assert-equal "buchberger"
  (map show-poly (buchberger {f1 f2} {x y}))
  {"y^3 - y^2" "x^2 - y^2" "x y^2 - y^2"})
(assert-equal "buchberger"
  (map show-poly (buchberger fs1 {x y z}))
  {"z - 3" "x - 1" "y - 2"})

; ==============================================================================

(define $show-mono
  (lambda [$mono]
    (S.intercalate " "
      (match-all mono monomial
        {[<power $x $n>
          (if (eq? n 1)
              (show x)
              (S.concat {(show x) "^" (show n)}))]
         [<nil> "1"]}))))

(define $show-coeff-mono
  (lambda [$c $x]
    (match [c x] [integer monomial]
      {[[,1         <nil>] "+ 1"]
       [[,-1        <nil>] "- 1"]
       [[?(gt? $ 0) <nil>] (S.append "+ " (show c))]
       [[?(lt? $ 0) <nil>] (S.append "- " (show (neg c)))]
       [[,1         $x]    (S.append "+ " (show-mono x))]
       [[,-1        $x]    (S.append "- " (show-mono x))]
       [[?(gt? $ 0) $x]    (S.concat {"+ " (show c) (show-mono x)})]
       [[?(lt? $ 0) $x]    (S.concat {"- " (show (neg c)) (show-mono x)})]
       })))

(define $show-coeff-mono-head
  (lambda [$c $x]
    (match [c x] [integer monomial]
      {[[,1         <nil>] "1"]
       [[,-1        <nil>] "- 1"]
       [[?(gt? $ 0) <nil>] (show c)]
       [[?(lt? $ 0) <nil>] (S.append "- " (show (neg c)))]
       [[,1         $x]    (show-mono x)]
       [[,-1        $x]    (S.append "- " (show-mono x))]
       [[?(gt? $ 0) $x]    (S.append (show c) (show-mono x))]
       [[?(lt? $ 0) $x]    (S.concat {"- " (show (neg c)) (show-mono x)})]
       })))

(define $show-poly
  (match-lambda (list [integer monomial])
    {[<nil> "0"]
     [<cons $x $xs>
      (let {[$first (show-coeff-mono-head x)]}
        (S.intercalate " " {first @(map show-coeff-mono xs)}))]}))

(define $debug/fn
  (macro [$show $x]
    (io (do {[(print (show x))]}
          (return x)))))

(define $replicate
  (lambda [$n $x] (take n (repeat1 x))))
