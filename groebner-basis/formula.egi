(load-file "example.egi")

(define $symbol something)

(define $monomial
  (matcher
    {[<degree $> [integer]
      {[$tgt {(sum (map snd tgt))}]}]
     [<power ,$x $> [symbol integer]
      {[$tgt (match tgt (multiset [symbol integer])
               {[<cons [,x $n] _> {n}]
                [_                {0}]})]}]
     [<power $ $> [symbol integer]
      {[$tgt tgt]}]
     [<mult ,$val $> [monomial]
      {[$tgt (div val tgt)]}]
     [$ (multiset [symbol integer])
      {[$tgt {tgt}]}]
     }))

(define $div
  (lambda [$divisor $dividend] ; dividend / divisor
    (match [divisor dividend] [(list [symbol integer]) (multiset [symbol integer])]
      {[[<nil> _] {dividend}]
       [[<cons [$x $n] $r1> <cons [,x (& ?(lte? n $) $m)] $r2>]
        (match (div r1 r2) (list something)
          {[<nil> {}]
           [<cons $result <nil>>
                  (if (eq? n m)
                      {result}
                      {(cons [x (- m n)] result)})]})]
       [_ {}]})))

(assert-equal "degree"
  (match {} monomial {[<degree $n> n]})
  0)
(assert-equal "degree"
  (match {[x 2] [y 1]} monomial {[<degree $n> n]})
  3)
(assert-equal "power"
  (match-all {[x 2] [y 1]} monomial {[<power $x $n> [x n]]})
  {[x 2] [y 1]})
(assert-equal "power"
  (match {[x 2] [y 1]} monomial {[<power ,z $n> n]})
  0)
(assert "mult"
  (eq?/m monomial
         (match {[x 2] [y 1]} monomial {[<mult ,{[x 1]} $rem> rem]})
         {[y 1] [x 1]}))
(assert-equal "mult"
  (match-all {[x 2] [y 1]} monomial {[<mult ,{[x 3]} $rem> rem]})
  {})

(define $polynomial
  (matcher
    {[<head ,$ord $ $> [integer monomial]
      {[$tgt {(max/fn (lambda [$m1 $m2] (ord-mono-lex ord (snd m1) (snd m2)))
                      tgt)}]}]
     [$ (multiset [integer monomial])
      {[$tgt {tgt}]}]
     }))

(assert-equal "head"
  (match {[1 {[x 1]}] [1 {[x 2]}]} polynomial {[<head ,{x} $n $x> [n x]]})
  [1 {[x 2]}])

; Lexicographic Ordering
(define $ord-mono-lex
  (lambda [$l $m1 $m2]
    (match [l m1 m2] [(list symbol) monomial monomial]
      {[[<nil> _ _] <Equal>]
       [[<cons $x $xs> <power ,x $n1> <power ,x $n2>]
        (match (compare n1 n2) ordering
          {[<equal> (ord-mono-lex xs m1 m2)]
           [$cmp    cmp]})]})))

; Graded Lexicographic Ordering
(define $ord-mono-grlex
  (match-lambda [(list symbol) monomial monomial]
    {[[_ <degree $n1> <degree (& !,n1 $n2)>]
      (compare n1 n2)]
     [[$sym-list $m1 $m2]
      (ord-mono-lex sym-list m1 m2)]}))

(assert-equal "ord-mono-lex"
  (ord-mono-lex {x y z} {[x 1] [y 2]} {[y 3] [z 2]})
  <Greater>)
(assert-equal "ord-mono-lex"
  (ord-mono-lex {x y z} {[x 2] [y 3] [z 3]} {[x 2] [y 1] [z 5]})
  <Greater>)
(assert-equal "ord-mono-grlex"
  (ord-mono-grlex {x y z} {[x 1] [y 3] [z 2]} {[x 4] [y 1]})
  <Greater>)
(assert-equal "ord-mono-grlex"
  (ord-mono-grlex {x y z} {[x 1] [y 3] [z 2]} {[x 1] [y 1] [z 4]})
  <Greater>)

(define $non-heads
  (lambda [$poly $ord]
    (match poly polynomial
      {[<head ,ord $c $mono> (delete-first [c mono] poly)]})))

(assert-equal "non-heads"
  (non-heads {[1 {[x 2]}] [1 {[y 1]}] [1 {}]} {x y})
  {[1 {[y 1]}] [1 {}]})

(define $negate
  (match-all-lambda polynomial
    {[<cons [$c $mono] _> [(neg c) mono]]}))

(define $mult-mono
  (match-all-lambda [monomial monomial]
    {[[<cons [$x $n] _> <cons [,x $m] _>] [x (+ n m)]]
     [[<cons [$x $n] _> !<cons [,x _] _>] [x n]]
     [{[# <cons [$x $n] _>] !<cons [,x _] _>} [x n]]
     }))

(assert "mult-mono"
  (eq?/m (multiset something)
         (mult-mono {[x 1] [y 2]} {[y 1] [z 2]})
         {[x 1] [y 3] [z 2]}))
(assert "mult-mono"
  (eq?/m (multiset something)
         (mult-mono {} {[y 1] [z 2]})
         {[y 1] [z 2]}))

(define $mult
  (match-all-lambda [[integer monomial] polynomial]
    {[[[$c1 $m1] <cons [$c2 $m2] _>]
      [(* c1 c2) (mult-mono m1 m2)]]
     }))

(assert-equal "mult"
  (mult [2 {[x 1]}] {[2 {[x 1] [y 1]}] [-1 {[x 1]}]}) ; 2x * (2xy - x)
  {[4 {[x 2] [y 1]}] [-2 {[x 2]}]})

(define $plus
  (match-all-lambda [polynomial polynomial]
    {[[<cons [$c1 $m1] _> !<cons [_ ,m1] _>] [c1 m1]]
     [[<cons [$c1 $m1] _> <cons [(& !,(neg c1) $c2) ,m1] _>] [(+ c1 c2) m1]]
     [{[# <cons [$c2 $m2] _>] !<cons [_ ,m2] _>} [c2 m2]]
     }))

(assert "plus"
  (eq?/m (multiset something)
         (plus {[2 {x y}] [-1 {x}]} {[1 {x y}] [-1 {y}]})
         {[3 {x y}] [-1 {x}] [-1 {y}]}))

; ==============================================================================

(define $show-mono
  (lambda [$mono]
    (S.intercalate " "
      (match-all mono monomial
        {[<power $x $n>
          (if (eq? n 1)
              (show x)
              (S.concat {(show x) "^" (show n)}))]
         [<nil> "1"]}))))

(define $show-coeff-mono
  (lambda [$c $x]
    (match [c x] [integer monomial]
      {[[,1         <nil>] "+ 1"]
       [[,-1        <nil>] "- 1"]
       [[?(gt? $ 0) <nil>] (S.append "+ " (show c))]
       [[?(lt? $ 0) <nil>] (S.append "- " (show (neg c)))]
       [[,1         $x]    (S.append "+ " (show-mono x))]
       [[,-1        $x]    (S.append "- " (show-mono x))]
       [[?(gt? $ 0) $x]    (S.concat {"+ " (show c) (show-mono x)})]
       [[?(lt? $ 0) $x]    (S.concat {"- " (show (neg c)) (show-mono x)})]
       })))

(define $show-coeff-mono-head
  (lambda [$c $x]
    (match [c x] [integer monomial]
      {[[,1         <nil>] "1"]
       [[,-1        <nil>] "- 1"]
       [[?(gt? $ 0) <nil>] (show c)]
       [[?(lt? $ 0) <nil>] (S.append "- " (show (neg c)))]
       [[,1         $x]    (show-mono x)]
       [[,-1        $x]    (S.append "- " (show-mono x))]
       [[?(gt? $ 0) $x]    (S.append (show c) (show-mono x))]
       [[?(lt? $ 0) $x]    (S.concat {"- " (show (neg c)) (show-mono x)})]
       })))

(define $show-poly
  (match-lambda (list [integer monomial])
    {[<nil> "0"]
     [<cons $x $xs>
      (let {[$first (show-coeff-mono-head x)]}
        (S.intercalate " " {first @(map show-coeff-mono xs)}))]}))

(define $col-show/fn
  (lambda [$show $set]
    (S.concat {"{" (S.intercalate ",\n " (map show set)) "}"})))

(define $show-polys
  (col-show/fn show-poly $1))

(define $debug/fn
  (macro [$show $x]
    (io (do {[(print (show x))]}
          (return x)))))
