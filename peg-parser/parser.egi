(define $digit?
  (lambda [$c] (c.between? c#0 c#9 c)))
(define $whitespace?
  (lambda [$c] (any (eq? $ c) {c#  c#\n c#\t})))

(define $expr
  (algebraic-data-matcher
    {<add expr expr>
     <mult expr expr>
     <int integer>}))

(define $L.number (pattern-function [$x $p] <parse-number x <sc p>>))
(define $L.char   (pattern-function [$x $p] <parse-char   x <sc p>>))
(define $L.string (pattern-function [$x $p] <parse-string x <sc p>>))

(define $parser
  (matcher
    {[<expr1 $ $> [expr parser]
      {[$tgt (match tgt parser
               {[<expr2 $n (L.char ,c#+ <expr1 $m $p>)>
                 {[<Add n m> p]}]
                [<expr2 $n $p>
                 {[n p]}]
                [_ {}]})]}]
     [<expr2 $ $> [expr parser]
      {[$tgt (match tgt parser
               {[<atomExpr $n (L.char ,c#* <expr2 $m $p>)>
                 {[<Mul n m> p]}]
                [<atomExpr $n $p>
                 {[n p]}]
                [_ {}]})]}]
     [<atomExpr $ $> [expr parser]
      {[$tgt (match tgt parser
               {[(L.number $n $p) {[<Int n> p]}]
                [(L.string ,"(" <expr1 $n (L.string ,")" $p)>) {[n p]}]
                [_ {}]})]}]

     ;; literals
     [<parse-number $ $> [integer parser]
      {[$tgt (match tgt string
               {[<regex ,"[0-9]+" <nil> $num $r> {[(read num) r]}]
                [_ {}]})]}]
     [<parse-char $ $> [char parser]
      {[$tgt (match tgt string
               {[<cons $x $xs> {[x xs]}]
                [_ {}]})]}]
     [<parse-string $ $> [string parser]
      {[$tgt (match-all tgt string
               {[<join $xs $ys> [xs ys]]})]}]
     [<sc $> [parser]
      {[$tgt (match tgt string
               {[(loop $i [1 _]
                       <cons ?whitespace? ...>
                       (& $r !<cons ?whitespace? _>))
                 {r}]
                [_ {}]})]}]
     [<eof> []
      {[$tgt (if (S.empty? tgt) {[]} {})]}]
     [$ [something]
      {[$tgt {tgt}]}]
     }))

(assert-equal "parser"
  (match "123 4" parser {[(L.number $n (L.number $m <eof>)) [n m]]})
  [123 4])
(assert-equal "parser"
  (match "123 4" parser {[(L.number $n (L.number ,4 <eof>)) n]})
  123)
(assert-equal "parser"
  (match "123 c" parser {[(L.number $n (L.char $c <eof>)) [n c]]})
  [123 c#c])
(assert-equal "parser"
  (match "123 c" parser {[(L.number $n (L.string ,"c" <eof>)) n]})
  123)
(assert-equal "parser"
  (match "1 + 2 + 3" parser {[<expr1 $n <eof>> n]})
  <Add <Int 1> <Add <Int 2> <Int 3>>>)
(assert-equal "parser"
  (match "1 + 2 * 3" parser {[<expr1 $n <eof>> n]})
  <Add <Int 1> <Mul <Int 2> <Int 3>>>)
(assert-equal "parser"
  (match "(1 + 2) * 3" parser {[<expr1 $n <eof>> n]})
  <Mul <Add <Int 1> <Int 2>> <Int 3>>)
