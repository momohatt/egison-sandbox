(define $symbol something)

(define $monomial
  (matcher
    {[<degree $> [integer]
      {[$tgt {(length tgt)}]}]
     [<power ,$x $> [integer]
      {[$tgt (match tgt (multiset symbol)
               {[(loop $i [1 $n]
                       <cons ,x ...>
                       !<cons ,x _>) {n}]})]}]
     [<mult ,$val $> [monomial]
      {[$tgt {(difference tgt val)}]}]
     [<mult $ $> [monomial monomial]
      ; TODO: is there more efficient implementation without unique?
      {[$tgt (unique (match-all tgt (multiset symbol)
                       [<join $xs $ys> [xs ys]]))]}]
     [<cons $ $> [symbol monomial]
      {[$tgt (unique tgt)]}]
     [$ (multiset symbol)
      {[$tgt {tgt}]}]
     }))

(define $polynomial
  (matcher
    {[<occur $> [monomial]
      {[$tgt (map snd tgt)]}]
     [<head $ $> [integer monomial]
      {[$tgt {(max/fn (lambda [$m1 $m2] (ord-mono (snd m1) (snd m2))) tgt)}]}]
     [$ (multiset [integer monomial])
      {[$tgt {tgt}]}]
     }))

(define $ord-mono
  (match-lambda [monomial monomial]
    {[[<degree $n1> <degree $n2>]
      (compare n1 n2)]}))

(define $non-heads
  (lambda [$poly]
    (match poly polynomial
      {[<head $c $mono> (delete-first [c mono] poly)]})))

(define $negate
  (match-all-lambda polynomial
    {[<cons [$c $mono] _> [(neg c) mono]]}))

(define $mult
  (match-all-lambda [[integer monomial] polynomial]
    {[[[$c1 $m1] <cons [$c2 $m2] _>]
      [(* c1 c2) {@m1 @m2}]]
     }))

(define $plus append)

(define $rewrite
  (lambda [$eqs $poly]
    (match [eqs poly] [(multiset polynomial) polynomial]
      {[[<cons (& $rule <head ,1 $hf>) _> <cons [$a <mult ,hf $m'>] $rs>]
        (plus rs (mult [a m'] (negate (non-heads rule))))]
       })))

(rewrite {f1 f2} {[1 {x x y y}]})

; ==============================================================================

(define $f1 {[1 {x x y}] [-1 {x x}]})
(define $f2 {[1 {x y y}] [-1 {y y}]})

; 2 x^2 y - x y^2 + 5 x + 17
(define $f3 {[2 {x x y}] [-1 {x y y}] [5 {x}] [17 {}]})

(assert-equal "occur"
  (match-all f3 polynomial [<occur $m> m])
  {{x x y} {x y y} {x} {}})

; ==============================================================================

(define $show-mono
  (lambda [$mono]
    (S.intercalate " "
      (match-all mono monomial
        {[(& <cons $x _> <power ,x $n>)
          (if (eq? n 1)
              (show x)
              (S.concat {(show x) "^" (show n)}))]
         [<nil> "1"]}))))

(define $show-poly
  (lambda [$poly]
    (S.intercalate " + "
       (map
         (match-lambda [integer monomial]
           {[[,1 $x] (show-mono x)]
            [[,-1 $x] (S.append "-" (show-mono x))]
            [[$c $x] (S.append (show c) (show-mono x))]})
         poly))))
